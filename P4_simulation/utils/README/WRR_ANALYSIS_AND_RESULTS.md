# WRR 分析与结果综合文档

本文档整合了所有 WRR 调度器的分析、测试结果和调试过程，包括拥塞程度分析、测试结果对比、原因分析和完整调试记录。

---

## 目录

1. [项目概述](#项目概述)
2. [拥塞程度分析](#拥塞程度分析)
3. [测试结果分析](#测试结果分析)
4. [原因分析](#原因分析)
5. [完整调试过程](#完整调试过程)
6. [关键发现总结](#关键发现总结)

---

## 项目概述

### 目标

测试和验证 WRR (Weighted Round Robin) 调度器在不同权重配置下的行为，特别是：
- **带宽分配**：验证不同权重 flow 的带宽分配是否符合预期
- **延迟差异**：验证高权重 flow 是否具有更低的延迟

### 测试环境

- **P4 仿真环境**：Mininet + BMv2
- **调度器**：自定义 WRR 实现（`WRR.h`）
- **拓扑**：单交换机，3 个发送端（h1, h2, h3），3 个接收端（h_r1, h_r2, h_r3）
- **初始配置**：quantums = {20000, 10000, 2000} (10:5:1)

---

## 拥塞程度分析

### 拥塞程度的定义

**拥塞程度** = 发送速率 / 调度器速率

- **拥塞程度 > 1.0**：有拥塞，队列会积压
- **拥塞程度 = 1.0**：临界状态
- **拥塞程度 < 1.0**：无拥塞，所有包都能及时发送

### 实际发送速率计算

**30ms 配置（--rate=0.0001）**：

| Flow | 实际发送速率 | 说明 |
|------|-------------|------|
| Flow 0 | 18.23 pps | 60秒内发送1094个包 |
| Flow 1 | 17.89 pps | 60秒内发送1074个包 |
| Flow 2 | 18.00 pps | 60秒内发送1080个包 |
| **总计** | **54.13 pps** | 三个 flow 的总发送速率 |

**50ms 配置（--rate=0.0001）**：

| Flow | 实际发送速率 | 说明 |
|------|-------------|------|
| Flow 0 | 16.83 pps | 60秒内发送1009个包 |
| Flow 1 | 17.05 pps | 60秒内发送1022个包 |
| Flow 2 | 16.77 pps | 60秒内发送1006个包 |
| **总计** | **50.65 pps** | 三个 flow 的总发送速率 |

**关键发现**：
- ✅ 两种配置的实际发送速率相近（54.13 pps vs 50.65 pps）
- ✅ 说明发送速率主要受 Python `time.sleep()` 限制，而不是调度器速率

### 实际拥塞程度对比

| 配置 | 调度器速率 | 实际发送速率 | 实际拥塞程度 | 实际接收速率 | 差距 | 效果 |
|------|------------|--------------|--------------|--------------|------|------|
| 30ms | 33 pps | 54.13 pps | **1.64x** | 27-29 pps | 4-5 pps | ⚠️ |
| 50ms | 20 pps | 50.65 pps | **2.53x** | 17-19 pps | 1-3 pps | ✅ |

**关键发现**：
- ✅ 50ms 的拥塞程度更高（2.53x vs 1.64x）
- ✅ 50ms 的差距更小（1-3 pps vs 4-5 pps）
- ✅ 50ms 的效果更好（分配比例接近理论值）

### 拥塞程度要求

**只需要总拥塞程度 > 1** ✅

- 调度器速率是总速率（所有 flow 共享）
- 总发送速率决定拥塞
- 每个 flow 的拥塞程度不是关键

---

## 测试结果分析

### 50ms 配置测试结果

**测试配置**：
- **调度器速率**：`sleep_for(50ms)` = 20 pps
- **发送速率**：`--rate=0.00005`（理论 20000 pps）
- **quantums**：{40000, 10000, 2000} (20:5:1)
- **理论分配**：Flow 0 = 76.92%, Flow 1 = 19.23%, Flow 2 = 3.85%

**Window 1-7：非常接近理论值！✅**

| Window | Flow 0 | Flow 1 | Flow 2 | 总速率 |
|--------|--------|--------|--------|--------|
| 1      | 76.60% | 19.15% | 4.26%  | 18.80 pps |
| 2      | 76.76% | 19.46% | 3.78%  | 18.50 pps |
| 3      | 75.84% | 19.66% | 4.49%  | 17.80 pps |
| 4      | 76.40% | 19.66% | 3.93%  | 17.80 pps |
| 5      | 77.98% | 18.45% | 3.57%  | 16.80 pps |
| 6      | 75.43% | 20.00% | 4.57%  | 17.50 pps |
| 7      | 75.72% | 20.23% | 4.05%  | 17.30 pps |

**平均分配比例（Window 1-7）**：
- Flow 0: **76.39%**（理论 76.92%，误差 -0.53%）✅
- Flow 1: **19.52%**（理论 19.23%，误差 +0.29%）✅
- Flow 2: **4.09%**（理论 3.85%，误差 +0.24%）✅

### 30ms 配置测试结果

**测试配置**：
- **调度器速率**：`sleep_for(30ms)` = 33 pps
- **发送速率**：`--rate=0.0001`（理论 10000 pps）
- **quantums**：{40000, 10000, 2000} (20:5:1)
- **理论分配**：Flow 0 = 76.92%, Flow 1 = 19.23%, Flow 2 = 3.85%

**Window 1-5：分配比例有所改善，但仍偏离理论值**

| Window | Flow 0 | Flow 1 | Flow 2 | 总速率 |
|--------|--------|--------|--------|--------|
| 1      | 65.38% | 28.67% | 5.94%  | 28.60 pps |
| 2      | 66.08% | 28.32% | 5.59%  | 28.60 pps |
| 3      | 69.12% | 25.61% | 5.26%  | 28.50 pps |
| 4      | 61.62% | 31.73% | 6.64%  | 27.10 pps |
| 5      | 60.28% | 33.10% | 6.62%  | 28.70 pps |

**平均分配比例（Window 1-5）**：
- Flow 0: **64.50%**（理论 76.92%，误差 -12.42%）⚠️
- Flow 1: **29.49%**（理论 19.23%，误差 +10.26%）⚠️
- Flow 2: **6.01%**（理论 3.85%，误差 +2.16%）⚠️

---

## 原因分析

### 为什么 30ms 达不到 50ms 的效果？

**核心原因：调度器速率 vs 实际接收速率的差距 ⭐⭐⭐**

**30ms (33 pps) 的情况**：
- 调度器速率：33 pps
- 实际接收速率：27-29 pps
- **差距：4-5 pps（较大）** ⚠️

**问题**：
- 其他瓶颈（Mininet、网络栈等）影响较大
- WRR 轮询机制可能受到影响
- 分配比例偏离理论值（64.50% vs 76.92%）

**50ms (20 pps) 的情况**：
- 调度器速率：20 pps
- 实际接收速率：17-19 pps
- **差距：1-3 pps（很小）** ✅

**优势**：
- 调度器是主要瓶颈，其他瓶颈影响较小
- WRR 轮询机制充分发挥作用
- 分配比例接近理论值（76.39% vs 76.92%）

### 为什么 Flow 0 的带宽不能提高到 77%？

**核心原因：WRR 轮询机制的限制（最关键）⭐⭐⭐**

**WRR 的工作原理**：

```cpp
// First Round: 按顺序检查 flow 0, 1, 2
for (int i = 0; i < 3; i++) {
    if (quota_each_queue[i] >= packet_rank) {
        dequeue_right_id = i;
        break;  // ← 找到第一个就退出！
    }
}
```

**关键问题**：

1. **轮询顺序**：WRR 按顺序检查每个 flow（0→1→2）
2. **找到第一个就退出**：即使 Flow 0 的 quantum 更大，如果 Flow 1 或 Flow 2 先满足条件，它们会被选中
3. **每个调度周期只能处理 1 个包**：`sleep_for(30ms)` 限制了每个周期只能 dequeue 一个包

**关键发现**：

1. **Flow 0 虽然 quantum 更大，但不能"独占"所有带宽**
   - 因为 WRR 是轮询的，Flow 1 和 Flow 2 也会获得服务机会
   - 即使 Flow 0 的 quantum=40000，它也需要等待 Flow 1 和 Flow 2 的 quota 用尽

2. **在轮询机制下，分配比例受限于轮询顺序**
   - Flow 0 可以连续发送更多包（因为 quantum 更大）
   - 但 Flow 1 和 Flow 2 也会获得服务机会
   - **最终分配比例接近某个平衡点，而不是理论值**

---

## 完整调试过程

### 初始配置与测试

**问题**：队列没有积累包，FIFO bank 经常为空

**分析**：
- 调度速率（`sleep_for(10 microseconds)`）远高于发送速率（`--rate=0.01`）
- 包几乎立即被 dequeue，队列无法积累

**解决方案**：
1. 增加发送速率：`--rate=0.001`（1000 pps/流）
2. 增加调度延迟：`sleep_for(10ms)`（100 pps 调度速率）

### 性能优化

**问题**：Debug 日志影响性能

**解决方案**：
1. 禁用所有 WRR logging：`#define WRR_DISABLE_LOGGING 1`
2. 注释掉 `receive.py` 中的 `pkt.show2()` 以减少接收端开销

**结果**：性能显著提升，调度器速率更接近理论值

### 瓶颈分析

经过分析，确定了以下瓶颈（按重要性排序）：

1. **WRR 调度器速率**（主要瓶颈）⭐⭐⭐
   - 当前配置：`sleep_for(30ms)` = 33 pps
   - 这是带宽分配的主要限制因素

2. **Python `time.sleep()` 精度**⭐⭐
   - 系统定时器精度限制（1-10ms）
   - 限制实际发送速率的提升

3. **BMv2 TM_semaphore**⭐
   - BMv2 内部的流量管理器信号量
   - 可能成为软件开销的一部分

### 调度器速率调整

#### 阶段 1：`sleep_for(10ms)` = 100 pps

**结果**：
- 总接收速率：~48 pps
- 拥塞程度：0.48x（无拥塞）
- 带宽分配：33.33% for all flows（Round Robin）

#### 阶段 2：`sleep_for(20ms)` = 50 pps

**结果**：
- 总接收速率：~48 pps
- 拥塞程度：0.96x（接近拥塞）
- 带宽分配：开始有差异，但不够明显

#### 阶段 3：`sleep_for(30ms)` = 33 pps

**结果**：
- 总接收速率：~28-30 pps
- 拥塞程度：0.85-0.9x（中等拥塞）
- **带宽分配**：Flow 0: 61%, Flow 1: 32%, Flow 2: 7%（接近理论值）

#### 阶段 4：`sleep_for(50ms)` = 20 pps ✅

**结果**：
- 总接收速率：~17-19 pps
- 拥塞程度：2.53x（较强拥塞）
- **带宽分配**：Flow 0: 76.39%, Flow 1: 19.52%, Flow 2: 4.09%（非常接近理论值）✅

---

## 关键发现总结

### 1. 50ms 配置效果最好 ✅

**Window 1-7 的结果**：
- Flow 0: 76.39%（理论 76.92%，误差 -0.53%）✅
- Flow 1: 19.52%（理论 19.23%，误差 +0.29%）✅
- Flow 2: 4.09%（理论 3.85%，误差 +0.24%）✅

**关键因素**：
- 调度器速率和实际接收速率差距很小（1-3 pps）✅
- 调度器是主要瓶颈，WRR 轮询机制充分发挥作用 ✅

### 2. 关键差异：调度器速率和实际接收速率的差距 ⭐⭐⭐

**30ms 配置**：
- 差距：4-5 pps（较大）⚠️
- 其他瓶颈影响较大
- WRR 轮询机制可能受到影响
- 分配比例偏离理论值

**50ms 配置**：
- 差距：1-3 pps（很小）✅
- 调度器是主要瓶颈
- WRR 轮询机制充分发挥作用
- 分配比例接近理论值

### 3. 关键理解

**当调度器速率和实际接收速率的差距较小时，效果最好**：

- **差距 < 3 pps**：调度器速率是主要瓶颈，WRR 轮询机制充分发挥作用 ✅
- **差距 > 3 pps**：其他瓶颈影响较大，WRR 轮询机制可能受到影响 ⚠️

### 4. 最佳实践

**目标**：让调度器速率成为主要瓶颈

**方法**：
1. **测量实际发送速率**：
   ```bash
   python3 calculate_send_rate.py ../program/qos/outputs
   ```

2. **测量实际接收速率**：
   ```bash
   python3 measure_bandwidth_allocation.py ../program/qos/outputs --congestion-only
   ```

3. **设置 sleep_for**：
   - 让调度器速率略高于实际接收速率
   - **关键**：确保调度器速率和实际接收速率的差距 < 3 pps
   - 例如：实际接收 18 pps → `sleep_for(55ms)` = 18.2 pps ✅

4. **验证拥塞程度**：
   - 确保拥塞程度 > 1.0（发送速率 > 调度器速率）✅
   - 确保调度器利用率 > 80%（实际接收速率 / 调度器速率 > 0.8）✅
   - **关键**：确保差距 < 3 pps ✅

---

**文档版本**：v2.0  
**最后更新**：整合所有分析与结果相关的文档  
**状态**：✅ 完成
